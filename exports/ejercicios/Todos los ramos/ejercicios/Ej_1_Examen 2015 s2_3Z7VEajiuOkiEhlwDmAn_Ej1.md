---
title: "Ejercicio 1"
topic: "General"
number: "1"
originalUrl: "exports/downloads/Todos los ramos/Examen 2015 s2_3Z7VEajiuOkiEhlwDmAn.pdf"
sourceFile: "Examen 2015 s2_3Z7VEajiuOkiEhlwDmAn.pdf"
---

(60 puntos) Resolver una   ecuación diofántica   de la forma:  a 1 x 1   +   a 2 x 2   +   · · ·   +   a n x n   =   C  consiste en encontrar valores dentro de un conjunto   D   de números enteros para las variables  x 1 , . . . , x n , dados los valores de   a 1 , . . . , a n   y el valor de   C . Escribe una función para resolver este tipo de ecuaciones, la que debe ser de tipo recursiva (fun- ciones sólo iterativas no serán evaluadas). De haber una solución, tu función deberá imprimir en pantalla una lista con los valores de   x 1   hasta   x n . En caso contrario, deberá imprimir “no hay solu- ción”. Tu función deberá recibir una lista no vacía de números enteros para los coeficientes   a 1 , . . . , a n , y un número entero para la constante   C . Además, deberá suponer que los valores de   x i   son números enteros entre   − 10   y   10 , es decir,   D   =   {− 10 ,   − 9 , . . . ,   9 ,   10 } . Por ejemplo, si quieres resolver la siguiente ecuación diofántica  2 x 1   + 3 x 2   = 5 ,  deberás llamar a tu función usando como argumentos la lista   [2, 3]   y el número   5 , y debería imprimir en pantalla, por ejemplo,   [-8, 7] , ya que   2   ×   ( − 8) + 3   ×   (7) = 5 . Nota que puede haber más de una solución; basta con que el programa imprima una solución válida (si la hay), no todas las soluciones. 2

--- Page 3 ---
Ejemplo solución problema 1  La solución 3 aplica especialmente a las respuestas de alumnos de la sección 2.  Solución 1  def resolver(sol,i,L,C): if L==[]: return   C==0 d=-10 while   d<=10: sol[i]=d if   resolver(sol,i+1,L[1:],C-L[0]*d): return   True d =   d   +   1 return   False def diofantica(L,C): sol=[0]*len(L) if resolver(sol,0,L,C): print(sol) else: print("no   hay   solucion")  Solución 2  def resolver(listaA,   C,   listaX): #CASO BASE:   valores   para   todas las X if len(listaA)   ==   len(listaX): suma   =   0 for   i   in   range(0,len(listaA)): suma   +=   listaA[i]*listaX[i] if   suma   ==   C: return   True return   False # Pongo   un   valor   a   la   ’x’ else: for   i   in   range(-10,10+1): listaX.append(i) if   resolver(listaA, C, listaX): return   True listaX.pop() return   False def diofantica(listaA,   C): listaX   =   [] if resolver(listaA,   C,   listaX):  3

--- Page 4 ---
print(listaX) else: print("No   tiene   solucion")  Solución 3 (con plantilla)  import sys class Diofantica: coef_a   =   [] C = 0 min =   0 max =   9 def __init__(self,   coef_a, C, min, max): self.coef_a   =   coef_a self.C   =   C self.min   =   min self.max   =   max # Evalua   una   posible   solucion def Evaluar(self,   solucion): suma   =   0 for   i   in   range(len(self.coef_a)): suma   +=   self.coef_a[i]   * solucion[i] return   suma   ==   self.C # Retorna   True   si   vale   la   pena explorar la solución candidata def SirveComoSolucionParcial(self, solucion_candidata): if   len(solucion_candidata) > len(self.coef_a): return   False else: return   True # Retorna   True   si   la   solución candidata resuelve el problema def SirveComoSolucionFinal(self, solucion_candidata): if   len(solucion_candidata) < len(self.coef_a): return   False else: return   self.Evaluar(solucion_candidata) # Usa la   solución   candidata como una solución valida al problema def MostrarSolucionFinal(self, solucion_candidata): print("Solucion:",   solucion_candidata) # Genera   una   lista   de   soluciones extendidas, derivadas de la solución   candidata def ObtenerSolucionesCandidatas(self, solucion_candidata): listaCandidatas   =   [] for   v   in   range(self.min, self.max+1): listaCandidatas.append(solucion_candidata + [v]) return   listaCandidatas  4

--- Page 5 ---
# Retorna   una   solución   candidata inicial def SolucionInicial(self): return   [] # Backtracking   genérico def Backtracking(self,   solucion_candidata): if   not   self.SirveComoSolucionParcial(solucion_candidata): return   False if   self.SirveComoSolucionFinal(solucion_candidata): self.MostrarSolucionFinal(solucion_candidata) return   True lista_candidatas   =   self.ObtenerSolucionesCandidatas(solucion_candidata) for   solucion   in   lista_candidatas: if   self.Backtracking(solucion): return   True  5

--- Page 6 ---
Criterios de evaluación problema 1 Nota : esta pregunta tiene dos criterios de evaluación. El descrito en la tabla es general, excepto para la sección 2, donde es opcional usar una plantilla para solucionar problemas de backtracking. En el caso de un alumno que usó la plantilla (un set de funciones), usar el criterio de solución con plantilla descrito después de la tabla general.  Aspecto   No logrado   Logrado con observaciones   Logrado  Función recursiva para   resolver   la ecuación   diofán- tica (60 pts) Sin   código, código   tiene errores   mayores, o   código   no corresponde   a un   algoritmo recursivo (0 pts) Definición de caso base (5 pts) Recursión sobre elementos de   x   (10 pts) Iteración o recursión por valores de   D   por cada   x   (5 pts) Criterio de término de re- cursión (5 pts) Impresión en pantalla de solución o mensaje de "no hay   soluciónçon   errores menores, o retorna la solu- cion en vez de imprimir en pantalla. (5 pts) Definición de caso base (10 pts) Recursión para generar la lista de   x   (20 pts) Iteración o recursión por valores de   D   por cada   x  (10 pts) Criterio de término de re- cursión (10 pts) Impresión en pantalla de solución o mensaje de "no hay solución"(10 pts)  Criterios de evaluación problema 1 con plantilla  1. Correcta implementación de función/método   SirveComoSolucionParcial(solucion_candidata)  (5 pts) 0 a 5 pts – toda solución parcial es válida, pero no puede pasarse del número de ele- mentos de la lista de   x . 2. Correcta implementación de función/método   SirveComoSolucionFinal(solucion_candidata)  (20 pts) 0 a 5 pts – chequear que se requiere tener la misma cantidad de elementos que coefi- cientes   a i . 0 a 15 pts – chequear que se cumpla la ecuación. 3. Correcta implementación de función/método   MostrarSolucionFinal(solucion_candidata)  (5 pts) 6

--- Page 7 ---
0 a 5 pts - Impresión en pantalla de solución. 4. Correcta implementación de función/método   ObtenerSolucionesCandidatas(solucion_candidata)  (10 pts) 0 a 5 pts – Iteración por valores de   D   por cada   x i  0 a 5 pts – Construcción de lista de soluciones candidatas para siguiente nivel de recur- sión. 5. Correcta implementación de función/método   SolucionInicial()   (5 pts) 0 a 5 pts – Solución inicial es simplemente una lista vacía. 6. Correcta implementación de función/método   Backtracking(solucion_candidata) : (10 pts) 0 a 5 pts – Buen uso de la plantilla 0 a 5 pts – Identificar que la solución candidata corresponde a asignar valores a un   x i  más en cada llamado en profundidad a la función Backtracking 7. Impresión en pantalla de mensaje de "no hay solución"(5 pts) 0 a 5 pts – se reconoce que no se encontró solución y se despliega mensaje “no hay solución” 7

--- Page 8 ---