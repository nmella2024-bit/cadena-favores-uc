---
title: "Ejercicio 2"
topic: "General"
number: "2"
originalUrl: "exports/downloads/Todos los ramos/IIC1103 2014.01 Control_2_Diccionarios_1-2_Solución_4LcmTofIXm6ExbUuSY6f.pdf"
sourceFile: "IIC1103 2014.01 Control_2_Diccionarios_1-2_Solución_4LcmTofIXm6ExbUuSY6f.pdf"
---

Los compradores más expertos, que hacen rendir más su dinero, han observado que el  mayor beneficio por compra se calc ula de la relación valor versus formato (tamaño), es  decir para comparar productos, en términos de decir cual es más barato, importa el  precio, pero también el formato (tamaño), y la mejor relación entre formato del producto  y precio, se da por lo general   con aquellos perfumes de mayor formato, pese a que el  valor puede ser más alto. Es decir, el valor que ello s asocian al producto para comp ra r es  $valor/formato. En base a este criterio, se te pide que escribas una función en Python, que

--- Page 3 ---
reciba como parámet ro el catalogo de productos, y retorne una lista ordenada con los  perfumes de cada marca que tengan la mejor relación precio formato.  Solució n:  #   Se   implementa   s ólo   si   se   usó   la   function   sorted   para   ordenar  def   clave 2 ( item ):  return   item [ 5 ]  def   baratos_ml ( catalogo ):  resu ltado   =   []  #   paso   1  #   buscar   por   marca   que   perfume   tiene   la   mejor   relacion   precio  #   cantidad  for   marca   in   catalogo :  producto_m   =   catalogo [ marca ][ 0 ]  relacion   =   producto_m [ 3 ]/ producto_m [ 2 ]  for   i   in   range ( 1 , len ( catalogo [ marca ])):  producto   =   catalogo [ marca ][ i ]  if   producto [ 3 ]/ producto [ 2 ]   <   relacion :  producto_m   =   producto  indice   =   producto [ 3 ]/ producto [ 2 ]  resultado . append (( marca , producto_m [ 0 ], producto_m [ 1 ],  producto_m [ 2 ] ,   producto_m [ 3 ], relacion ))  #   paso   2  #   Si   se   o rdena   la   lista   usando   sorted,   entonces   es   obligatorio  #   tener   implementada   la   función   que   retorna   la   posición   a   buscar  #   en   este   caso   es   clave 2   definida   el   comienzo  #   Si   no   se   usa   sorted,   entonces   cualquier   método   de   ordenamiendo  #   sirve   (inserción   o   selecci ón)  aux   =   sorted ( resultado ,   key   =   clave2 )  resultado_final   =   []  #   paso   3  #   dejar   la   lista   de   respuesta   final   en   el   format  #   (marca,producto)   entendiendo   que   un   producto   es   una   tupla  for   elemento   in   aux :  resultado_final . append (( elemento [ 0 ],( elemento [ 1 ],  elemento [ 2 ],   elemento [ 3 ], elemento [ 4 ])))  return   resultado_final