(60 puntos) Debes completar el programa que se muestra más abajo. Este programa modela la interacción entre los siguientes objetos: dos   cocineros , un   mesón , y dos   mozos   del restorán   Don Yadran . Los   cocineros   ponen platos en el   mesón   para que sean retirados por los   mozos . El mesón tiene un espacio limitado y los   cocineros   no pueden poner más platos cuando el   mesón   está lleno.   Don Yadran   es muy famoso y se especializa en solo dos tipos de platos: “ lomitos ” y “ completos ”. El  cocinero1   solo hace “ lomitos ” y el   cocinero2   sólo hace “ completos ”. Los   mozos   sacan platos del   mesón   (si es que los hay) y los ponen en una bandeja distribuidora que los llevan a los hambrientos clientes. El   mozo1   sólo saca del   mesón   platos “ lomitos ” y el   mozo2  sólo saca platos “ completos ”. El siguiente programa ejecuta muchas iteraciones de la interacción entre   cocineros ,   mesón   y   mo- zos . En cada iteración, cada   cocinero   prepara y pone en el   mesón   una cantidad aleatoria de (entre cero y   P ) platos. En el programa,   P   vale   6   ( “ lomitos ”) para   cocinero1   y   8   (“ completos ”) para  cocinero2 . Si un cocinero debe poner   x   platos en el   mesón , pero en éste sólo caben   k , con   k < x , sólo pone   k   platos. En cada iteración, cada   mozo   saca del   mesón   una cantidad aleatoria de (entre cero y   S ) platos. En el programa,   S   vale   5   ( “ lomitos ”) para   mozo1   y   4   (“ completos ”) para   mozo2 . Si un mozo debe sacar   x   platos del   mesón , pero en éste sólo quedan   k , con   k < x , sólo saca   k   platos. Debes completar este programa escribiendo las clases   Meson ,   Cocinero , y   Mozo , asegurando que funcione a cabalidad. No puedes modificar el código presentado. Debes definir las clases, atributos y métodos necesarios. El método   lleno()   retorna   True   si el   mesón   está lleno y   False   en caso contrario. El atributo   faltan   indica la cantidad de platos que no estaban disponibles en el   mesón  para ser retirados por un   mozo   (no se acumulan de una iteración a otra). El atributo   tipo   indica si es “ lomito ” o “ completo ”. El atributo   lom   indica la cantidad de “ lomitos ” en el   mesón . El atributo  comp   indica la cantidad de “ completos ” en el   mesón .  ### programa   principal   ### meson=Meson(20)   # crea un mesón de capacidad 20   platos cocinero1 =   Cocinero("lomito",6,meson)   # crea cocinero con máx. 6 lomitos cocinero2 =   Cocinero("completo",8,meson)   # crea cocinero con máx. 8 completos mozo1=Mozo("lomito",5,meson)   # crea mozo que retira máx. 5 lomitos mozo2=Mozo("completo",4,meson)   # crea mozo que retira máx. 4 completos t=0   #   ejecuta   50   iteraciones while t < 50: cocinero1.agregaPlatos() cocinero2.agregaPlatos() print("   Mesón   lleno   :   ",   meson.lleno()) mozo1.retiraPlatos() print("   Faltan   :   ",   mozo1.faltan," ",mozo1.tipo) mozo2.retiraPlatos() print("   Faltan   :   ",   mozo2.faltan," ",mozo2.tipo) t = t +   1 print ("t   =   "+str(t)   +   "   Meson: " + str(meson.lom) + ", " + str(meson.comp)) # fin de la   iteración  15

--- Page 16 ---
Ejemplo solución problema 4  import random class Meson: def __init__(self,   capacidad): self.capacidad   =   capacidad self.lom   =   0 self.comp   =   0 def lleno(self): return   self.capacidad   - self.lom - self.comp <= 0 class Mozo: def __init__(self,   tipo,   Max, meson): self.tipo   =   tipo self.Max   =   Max self.meson   =   meson self.faltan   =   0 def retiraPlatos(self): nPlatos   =   random.randint(0,self.Max) cuenta   =   0 for   i   in   range   (0,nPlatos): if   self.tipo   ==   "lomito" and not self.meson.lom <= 0: cuenta   +=   1 self.meson.lom   -= 1 elif   self.tipo   ==   "completo" and not self.meson.comp <= 0: cuenta   +=   1 self.meson.comp -= 1 self.faltan   =   nPlatos   - cuenta class Cocinero: def __init__(self,tipo,Max,meson): self.tipo   =   tipo self.Max   =   Max self.meson   =   meson def agregaPlatos(self): nPlatos   =   random.randint(0,self.Max) cuenta   =   0 for   i   in   range   (0,nPlatos): if   not   self.meson.lleno(): cuenta   +=   1 if   self.tipo   == "lomito": self.meson.lom += 1 else:   #   self.tipo == "completo" self.meson.comp += 1  16

--- Page 17 ---
Criterios de evaluación problema 4  Aspecto   No logrado   Logrado con observaciones   Logrado  Clase   Meson   (10 pts) Sin código, o códi- go   tiene   errores mayores (0 pts) Definición de clase, construc- tor y atributos (2 pts) Método   lleno   (2 pts) Definición de clase, construc- tor y atributos (5 pts) Método   lleno   (5 pts) Clase   Mozo   (25 pts) Sin código, o códi- go   tiene   errores mayores (0 pts) Definición de clase, construc- tor y atributos (5 pts) Método   retiraPlatos : generación   de   cantidad   de platos (2 pts) Método   retiraPlatos : actualización de platos reti- rados según tipo de plato (5 pts) Definición de clase, construc- tor y atributos (10 pts) Método   retiraPlatos : generación   de   cantidad   de platos (5 pts) Método   retiraPlatos : actualización de platos reti- rados según tipo de plato (10 pts) Clase   Cocinero  (25 pts) Sin código, o códi- go   tiene   errores mayores (0 pts) Definición de clase, construc- tor y atributos (5 pts) Método   agregaPlatos : generación   de   cantidad   de platos (2 pts) Método   agregaPlatos : actualización de platos agre- gados según tipo de plato (5 pts) Definición de clase, construc- tor y atributos (10 pts) Método   agregaPlatos : generación   de   cantidad   de platos (5 pts) Método   agregaPlatos : actualización de platos agre- gados según tipo de plato (10 pts)  17